{
  "version": 3,
  "sources": ["../../redaxios/src/index.js"],
  "sourcesContent": ["/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @public\n * @typedef Options\n * @property {string} [url] the URL to request\n * @property {'get'|'post'|'put'|'patch'|'delete'|'options'|'head'|'GET'|'POST'|'PUT'|'PATCH'|'DELETE'|'OPTIONS'|'HEAD'} [method=\"get\"] HTTP method, case-insensitive\n * @property {RequestHeaders} [headers] Request headers\n * @property {FormData|string|object} [body] a body, optionally encoded, to send\n * @property {'text'|'json'|'stream'|'blob'|'arrayBuffer'|'formData'|'stream'} [responseType=\"json\"] An encoding to use for the response\n * @property {Record<string,any>|URLSearchParams} [params] querystring parameters\n * @property {(params: Options['params']) => string} [paramsSerializer] custom function to stringify querystring parameters\n * @property {boolean} [withCredentials] Send the request with credentials like cookies\n * @property {string} [auth] Authorization header value to send with the request\n * @property {string} [xsrfCookieName] Pass an Cross-site Request Forgery prevention cookie value as a header defined by `xsrfHeaderName`\n * @property {string} [xsrfHeaderName] The name of a header to use for passing XSRF cookies\n * @property {(status: number) => boolean} [validateStatus] Override status code handling (default: 200-399 is a success)\n * @property {Array<(body: any, headers?: RequestHeaders) => any?>} [transformRequest] An array of transformations to apply to the outgoing request\n * @property {string} [baseURL] a base URL from which to resolve all URLs\n * @property {typeof window.fetch} [fetch] Custom window.fetch implementation\n * @property {any} [data]\n */\n\n/**\n * @public\n * @typedef RequestHeaders\n * @type {{[name: string]: string} | Headers}\n */\n\n/**\n * @public\n * @template T\n * @typedef Response\n * @property {number} status\n * @property {string} statusText\n * @property {Options} config the request configuration\n * @property {T} data the decoded response body\n * @property {Headers} headers\n * @property {boolean} redirect\n * @property {string} url\n * @property {ResponseType} type\n * @property {ReadableStream<Uint8Array> | null} body\n * @property {boolean} bodyUsed\n */\n\n/**\n * @typedef BodylessMethod\n * @type {<T=any>(url: string, config?: Options) => Promise<Response<T>>}\n */\n\n/**\n * @typedef BodyMethod\n * @type {<T=any>(url: string, body?: any, config?: Options) => Promise<Response<T>>}\n */\n\n/**\n * @public\n * @param {Options} [defaults = {}]\n * @returns {redaxios}\n */\nfunction create(defaults) {\n\tdefaults = defaults || {};\n\n\t/**\n\t * @public\n\t * @template T\n\t * @type {(<T = any>(config?: Options) => Promise<Response<T>>) | (<T = any>(url: string, config?: Options) => Promise<Response<T>>)}\n\t */\n\tredaxios.request = redaxios;\n\n\t/** @public @type {BodylessMethod} */\n\tredaxios.get = (url, config) => redaxios(url, config, 'get');\n\n\t/** @public @type {BodylessMethod} */\n\tredaxios.delete = (url, config) => redaxios(url, config, 'delete');\n\n\t/** @public @type {BodylessMethod} */\n\tredaxios.head = (url, config) => redaxios(url, config, 'head');\n\n\t/** @public @type {BodylessMethod} */\n\tredaxios.options = (url, config) => redaxios(url, config, 'options');\n\n\t/** @public @type {BodyMethod} */\n\tredaxios.post = (url, data, config) => redaxios(url, config, 'post', data);\n\n\t/** @public @type {BodyMethod} */\n\tredaxios.put = (url, data, config) => redaxios(url, config, 'put', data);\n\n\t/** @public @type {BodyMethod} */\n\tredaxios.patch = (url, data, config) => redaxios(url, config, 'patch', data);\n\n\t/** @public */\n\tredaxios.all = Promise.all.bind(Promise);\n\n\t/**\n\t * @public\n\t * @template Args, R\n\t * @param {(...args: Args[]) => R} fn\n\t * @returns {(array: Args[]) => R}\n\t */\n\tredaxios.spread = (fn) => /** @type {any} */ (fn.apply.bind(fn, fn));\n\n\t/**\n\t * @private\n\t * @template T, U\n\t * @param {T} opts\n\t * @param {U} [overrides]\n\t * @param {boolean} [lowerCase]\n\t * @returns {{} & (T | U)}\n\t */\n\tfunction deepMerge(opts, overrides, lowerCase) {\n\t\tlet out = /** @type {any} */ ({}),\n\t\t\ti;\n\t\tif (Array.isArray(opts)) {\n\t\t\t// @ts-ignore\n\t\t\treturn opts.concat(overrides);\n\t\t}\n\t\tfor (i in opts) {\n\t\t\tconst key = lowerCase ? i.toLowerCase() : i;\n\t\t\tout[key] = opts[i];\n\t\t}\n\t\tfor (i in overrides) {\n\t\t\tconst key = lowerCase ? i.toLowerCase() : i;\n\t\t\tconst value = /** @type {any} */ (overrides)[i];\n\t\t\tout[key] = key in out && typeof value == 'object' ? deepMerge(out[key], value, key == 'headers') : value;\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * Issues a request.\n\t * @public\n\t * @template T\n\t * @param {string | Options} urlOrConfig\n\t * @param {Options} [config = {}]\n\t * @param {any} [_method] (internal)\n\t * @param {any} [data] (internal)\n\t * @param {never} [_undefined] (internal)\n\t * @returns {Promise<Response<T>>}\n\t */\n\tfunction redaxios(urlOrConfig, config, _method, data, _undefined) {\n\t\tlet url = /** @type {string} */ (typeof urlOrConfig != 'string' ? (config = urlOrConfig).url : urlOrConfig);\n\n\t\tconst response = /** @type {Response<any>} */ ({ config });\n\n\t\t/** @type {Options} */\n\t\tconst options = deepMerge(defaults, config);\n\n\t\t/** @type {RequestHeaders} */\n\t\tconst customHeaders = {};\n\n\t\tdata = data || options.data;\n\n\t\t(options.transformRequest || []).map((f) => {\n\t\t\tdata = f(data, options.headers) || data;\n\t\t});\n\n\t\tif (options.auth) {\n\t\t\tcustomHeaders.authorization = options.auth;\n\t\t}\n\n\t\tif (data && typeof data === 'object' && typeof data.append !== 'function' && typeof data.text !== 'function') {\n\t\t\tdata = JSON.stringify(data);\n\t\t\tcustomHeaders['content-type'] = 'application/json';\n\t\t}\n\n\t\ttry {\n\t\t\t// @ts-ignore providing the cookie name without header name is nonsensical anyway\n\t\t\tcustomHeaders[options.xsrfHeaderName] = decodeURIComponent(\n\t\t\t\t// @ts-ignore accessing match()[2] throws for no match, which is intentional\n\t\t\t\tdocument.cookie.match(RegExp('(^|; )' + options.xsrfCookieName + '=([^;]*)'))[2]\n\t\t\t);\n\t\t} catch (e) {}\n\n\t\tif (options.baseURL) {\n\t\t\turl = url.replace(/^(?!.*\\/\\/)\\/?/, options.baseURL + '/');\n\t\t}\n\n\t\tif (options.params) {\n\t\t\turl +=\n\t\t\t\t(~url.indexOf('?') ? '&' : '?') +\n\t\t\t\t(options.paramsSerializer ? options.paramsSerializer(options.params) : new URLSearchParams(options.params));\n\t\t}\n\n\t\tconst fetchFunc = options.fetch || fetch;\n\n\t\treturn fetchFunc(url, {\n\t\t\tmethod: (_method || options.method || 'get').toUpperCase(),\n\t\t\tbody: data,\n\t\t\theaders: deepMerge(options.headers, customHeaders, true),\n\t\t\tcredentials: options.withCredentials ? 'include' : _undefined\n\t\t}).then((res) => {\n\t\t\tfor (const i in res) {\n\t\t\t\tif (typeof res[i] != 'function') response[i] = res[i];\n\t\t\t}\n\n\t\t\tif (options.responseType == 'stream') {\n\t\t\t\tresponse.data = res.body;\n\t\t\t\treturn response;\n\t\t\t}\n\n\t\t\treturn res[options.responseType || 'text']()\n\t\t\t\t.then((data) => {\n\t\t\t\t\tresponse.data = data;\n\t\t\t\t\t// its okay if this fails: response.data will be the unparsed value:\n\t\t\t\t\tresponse.data = JSON.parse(data);\n\t\t\t\t})\n\t\t\t\t.catch(Object)\n\t\t\t\t.then(() => {\n\t\t\t\t\tconst ok = options.validateStatus ? options.validateStatus(res.status) : res.ok;\n\t\t\t\t\treturn ok ? response : Promise.reject(response);\n\t\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @public\n\t * @type {AbortController}\n\t */\n\tredaxios.CancelToken = /** @type {any} */ (typeof AbortController == 'function' ? AbortController : Object);\n\n\t/**\n\t * @public\n\t * @type {Options}\n\t */\n\tredaxios.defaults = defaults;\n\n\t/**\n\t * @public\n\t */\n\tredaxios.create = create;\n\n\treturn redaxios;\n}\n\nexport default create();\n"],
  "mappings": "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",
  "names": ["create", "defaults", "deepMerge", "opts", "overrides", "lowerCase", "i", "out", "Array", "isArray", "concat", "toLowerCase", "key", "value", "redaxios", "urlOrConfig", "config", "_method", "data", "_undefined", "url", "response", "options", "customHeaders", "transformRequest", "map", "f", "headers", "auth", "authorization", "append", "text", "JSON", "stringify", "xsrfHeaderName", "decodeURIComponent", "document", "cookie", "match", "RegExp", "xsrfCookieName", "e", "baseURL", "replace", "params", "indexOf", "paramsSerializer", "URLSearchParams", "fetch", "method", "toUpperCase", "body", "credentials", "withCredentials", "then", "res", "responseType", "parse", "catch", "Object", "validateStatus", "status", "ok", "Promise", "reject", "request", "get", "delete", "head", "post", "put", "patch", "all", "bind", "spread", "fn", "apply", "CancelToken", "AbortController"]
}
