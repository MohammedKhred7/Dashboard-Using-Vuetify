{"version":3,"file":"redaxios.js","sources":["../src/index.js"],"sourcesContent":["/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @public\n * @typedef Options\n * @property {string} [url] the URL to request\n * @property {'get'|'post'|'put'|'patch'|'delete'|'options'|'head'|'GET'|'POST'|'PUT'|'PATCH'|'DELETE'|'OPTIONS'|'HEAD'} [method=\"get\"] HTTP method, case-insensitive\n * @property {RequestHeaders} [headers] Request headers\n * @property {FormData|string|object} [body] a body, optionally encoded, to send\n * @property {'text'|'json'|'stream'|'blob'|'arrayBuffer'|'formData'|'stream'} [responseType=\"json\"] An encoding to use for the response\n * @property {Record<string,any>|URLSearchParams} [params] querystring parameters\n * @property {(params: Options['params']) => string} [paramsSerializer] custom function to stringify querystring parameters\n * @property {boolean} [withCredentials] Send the request with credentials like cookies\n * @property {string} [auth] Authorization header value to send with the request\n * @property {string} [xsrfCookieName] Pass an Cross-site Request Forgery prevention cookie value as a header defined by `xsrfHeaderName`\n * @property {string} [xsrfHeaderName] The name of a header to use for passing XSRF cookies\n * @property {(status: number) => boolean} [validateStatus] Override status code handling (default: 200-399 is a success)\n * @property {Array<(body: any, headers?: RequestHeaders) => any?>} [transformRequest] An array of transformations to apply to the outgoing request\n * @property {string} [baseURL] a base URL from which to resolve all URLs\n * @property {typeof window.fetch} [fetch] Custom window.fetch implementation\n * @property {any} [data]\n */\n\n/**\n * @public\n * @typedef RequestHeaders\n * @type {{[name: string]: string} | Headers}\n */\n\n/**\n * @public\n * @template T\n * @typedef Response\n * @property {number} status\n * @property {string} statusText\n * @property {Options} config the request configuration\n * @property {T} data the decoded response body\n * @property {Headers} headers\n * @property {boolean} redirect\n * @property {string} url\n * @property {ResponseType} type\n * @property {ReadableStream<Uint8Array> | null} body\n * @property {boolean} bodyUsed\n */\n\n/**\n * @typedef BodylessMethod\n * @type {<T=any>(url: string, config?: Options) => Promise<Response<T>>}\n */\n\n/**\n * @typedef BodyMethod\n * @type {<T=any>(url: string, body?: any, config?: Options) => Promise<Response<T>>}\n */\n\n/**\n * @public\n * @param {Options} [defaults = {}]\n * @returns {redaxios}\n */\nfunction create(defaults) {\n\tdefaults = defaults || {};\n\n\t/**\n\t * @public\n\t * @template T\n\t * @type {(<T = any>(config?: Options) => Promise<Response<T>>) | (<T = any>(url: string, config?: Options) => Promise<Response<T>>)}\n\t */\n\tredaxios.request = redaxios;\n\n\t/** @public @type {BodylessMethod} */\n\tredaxios.get = (url, config) => redaxios(url, config, 'get');\n\n\t/** @public @type {BodylessMethod} */\n\tredaxios.delete = (url, config) => redaxios(url, config, 'delete');\n\n\t/** @public @type {BodylessMethod} */\n\tredaxios.head = (url, config) => redaxios(url, config, 'head');\n\n\t/** @public @type {BodylessMethod} */\n\tredaxios.options = (url, config) => redaxios(url, config, 'options');\n\n\t/** @public @type {BodyMethod} */\n\tredaxios.post = (url, data, config) => redaxios(url, config, 'post', data);\n\n\t/** @public @type {BodyMethod} */\n\tredaxios.put = (url, data, config) => redaxios(url, config, 'put', data);\n\n\t/** @public @type {BodyMethod} */\n\tredaxios.patch = (url, data, config) => redaxios(url, config, 'patch', data);\n\n\t/** @public */\n\tredaxios.all = Promise.all.bind(Promise);\n\n\t/**\n\t * @public\n\t * @template Args, R\n\t * @param {(...args: Args[]) => R} fn\n\t * @returns {(array: Args[]) => R}\n\t */\n\tredaxios.spread = (fn) => /** @type {any} */ (fn.apply.bind(fn, fn));\n\n\t/**\n\t * @private\n\t * @template T, U\n\t * @param {T} opts\n\t * @param {U} [overrides]\n\t * @param {boolean} [lowerCase]\n\t * @returns {{} & (T | U)}\n\t */\n\tfunction deepMerge(opts, overrides, lowerCase) {\n\t\tlet out = /** @type {any} */ ({}),\n\t\t\ti;\n\t\tif (Array.isArray(opts)) {\n\t\t\t// @ts-ignore\n\t\t\treturn opts.concat(overrides);\n\t\t}\n\t\tfor (i in opts) {\n\t\t\tconst key = lowerCase ? i.toLowerCase() : i;\n\t\t\tout[key] = opts[i];\n\t\t}\n\t\tfor (i in overrides) {\n\t\t\tconst key = lowerCase ? i.toLowerCase() : i;\n\t\t\tconst value = /** @type {any} */ (overrides)[i];\n\t\t\tout[key] = key in out && typeof value == 'object' ? deepMerge(out[key], value, key == 'headers') : value;\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * Issues a request.\n\t * @public\n\t * @template T\n\t * @param {string | Options} urlOrConfig\n\t * @param {Options} [config = {}]\n\t * @param {any} [_method] (internal)\n\t * @param {any} [data] (internal)\n\t * @param {never} [_undefined] (internal)\n\t * @returns {Promise<Response<T>>}\n\t */\n\tfunction redaxios(urlOrConfig, config, _method, data, _undefined) {\n\t\tlet url = /** @type {string} */ (typeof urlOrConfig != 'string' ? (config = urlOrConfig).url : urlOrConfig);\n\n\t\tconst response = /** @type {Response<any>} */ ({ config });\n\n\t\t/** @type {Options} */\n\t\tconst options = deepMerge(defaults, config);\n\n\t\t/** @type {RequestHeaders} */\n\t\tconst customHeaders = {};\n\n\t\tdata = data || options.data;\n\n\t\t(options.transformRequest || []).map((f) => {\n\t\t\tdata = f(data, options.headers) || data;\n\t\t});\n\n\t\tif (options.auth) {\n\t\t\tcustomHeaders.authorization = options.auth;\n\t\t}\n\n\t\tif (data && typeof data === 'object' && typeof data.append !== 'function' && typeof data.text !== 'function') {\n\t\t\tdata = JSON.stringify(data);\n\t\t\tcustomHeaders['content-type'] = 'application/json';\n\t\t}\n\n\t\ttry {\n\t\t\t// @ts-ignore providing the cookie name without header name is nonsensical anyway\n\t\t\tcustomHeaders[options.xsrfHeaderName] = decodeURIComponent(\n\t\t\t\t// @ts-ignore accessing match()[2] throws for no match, which is intentional\n\t\t\t\tdocument.cookie.match(RegExp('(^|; )' + options.xsrfCookieName + '=([^;]*)'))[2]\n\t\t\t);\n\t\t} catch (e) {}\n\n\t\tif (options.baseURL) {\n\t\t\turl = url.replace(/^(?!.*\\/\\/)\\/?/, options.baseURL + '/');\n\t\t}\n\n\t\tif (options.params) {\n\t\t\turl +=\n\t\t\t\t(~url.indexOf('?') ? '&' : '?') +\n\t\t\t\t(options.paramsSerializer ? options.paramsSerializer(options.params) : new URLSearchParams(options.params));\n\t\t}\n\n\t\tconst fetchFunc = options.fetch || fetch;\n\n\t\treturn fetchFunc(url, {\n\t\t\tmethod: (_method || options.method || 'get').toUpperCase(),\n\t\t\tbody: data,\n\t\t\theaders: deepMerge(options.headers, customHeaders, true),\n\t\t\tcredentials: options.withCredentials ? 'include' : _undefined\n\t\t}).then((res) => {\n\t\t\tfor (const i in res) {\n\t\t\t\tif (typeof res[i] != 'function') response[i] = res[i];\n\t\t\t}\n\n\t\t\tif (options.responseType == 'stream') {\n\t\t\t\tresponse.data = res.body;\n\t\t\t\treturn response;\n\t\t\t}\n\n\t\t\treturn res[options.responseType || 'text']()\n\t\t\t\t.then((data) => {\n\t\t\t\t\tresponse.data = data;\n\t\t\t\t\t// its okay if this fails: response.data will be the unparsed value:\n\t\t\t\t\tresponse.data = JSON.parse(data);\n\t\t\t\t})\n\t\t\t\t.catch(Object)\n\t\t\t\t.then(() => {\n\t\t\t\t\tconst ok = options.validateStatus ? options.validateStatus(res.status) : res.ok;\n\t\t\t\t\treturn ok ? response : Promise.reject(response);\n\t\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @public\n\t * @type {AbortController}\n\t */\n\tredaxios.CancelToken = /** @type {any} */ (typeof AbortController == 'function' ? AbortController : Object);\n\n\t/**\n\t * @public\n\t * @type {Options}\n\t */\n\tredaxios.defaults = defaults;\n\n\t/**\n\t * @public\n\t */\n\tredaxios.create = create;\n\n\treturn redaxios;\n}\n\nexport default create();\n"],"names":["create","defaults","deepMerge","opts","overrides","lowerCase","i","out","Array","isArray","concat","toLowerCase","key","value","redaxios","urlOrConfig","config","_method","data","_undefined","url","response","options","customHeaders","transformRequest","map","f","headers","auth","authorization","append","text","JSON","stringify","xsrfHeaderName","decodeURIComponent","document","cookie","match","RegExp","xsrfCookieName","e","baseURL","replace","params","indexOf","paramsSerializer","URLSearchParams","fetch","method","toUpperCase","body","credentials","withCredentials","then","res","const","responseType","parse","catch","Object","validateStatus","status","ok","Promise","reject","request","get","delete","head","post","put","patch","all","bind","spread","fn","apply","CancelToken","AbortController"],"mappings":"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"}